 //
// Attention: Generated code! Do not modify by hand!
// Generated by: StrutsPatternMatchingExceptionHandler.vsl in andromda-bpm4struts-cartridge.
//

#set ($className = "ExceptionHandler")
#set ($generatedFile = "$stringUtils.replace($exceptionHandlerPackage, '.', '/')/${className}.java")
package $exceptionHandlerPackage;

import java.security.PrivilegedActionException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.List;
import java.util.StringTokenizer;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import javax.ejb.EJBException;

import org.apache.struts.Globals;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.apache.struts.action.ActionMessage;
import org.apache.struts.action.ActionMessages;
import org.apache.struts.config.ExceptionConfig;
import org.apache.struts.util.MessageResources;
import org.hibernate.HibernateException;
import org.hibernate.StaleStateException;
import org.hibernate.exception.ConstraintViolationException;
import org.hibernate.exception.DataException;
import org.hibernate.exception.GenericJDBCException;
import org.hibernate.exception.JDBCConnectionException;
import org.hibernate.exception.LockAcquisitionException;
import org.hibernate.exception.SQLGrammarException;

/**
 * <p/>
 *  A configurable pattern matching error handler retrieves exception mapping
 *  keys from an exception. This is used to retrieve keys from the back-end exceptions
 *  which can be mapped to exception messages keyed in an application resource
 *  file.
 * </p>
 */
public class ${className}
    extends org.apache.struts.action.ExceptionHandler
{

	private static Map excecoesPadrao;
	private static List listExcecoesPadrao;
	
	static{
		excecoesPadrao = new HashMap();
		listExcecoesPadrao = new ArrayList();
		listExcecoesPadrao.add(ConstraintViolationException.class);
		listExcecoesPadrao.add(DataException.class);
		listExcecoesPadrao.add(GenericJDBCException.class);
		listExcecoesPadrao.add(JDBCConnectionException.class);
		listExcecoesPadrao.add(LockAcquisitionException.class);
		listExcecoesPadrao.add(SQLGrammarException.class);
		listExcecoesPadrao.add(StaleStateException.class);
		listExcecoesPadrao.add(HibernateException.class);
		
		excecoesPadrao.put(ConstraintViolationException.class, "error.dafault.constraint.violation.exception");
		excecoesPadrao.put(DataException.class, "error.default.data.exception");
		excecoesPadrao.put(GenericJDBCException.class, "error.default.generic.jdbc.exception");
		excecoesPadrao.put(JDBCConnectionException.class ,"error.default.jdbc.connection.exception");
		excecoesPadrao.put(LockAcquisitionException.class, "error.default.lock.acquisition.exception");
		excecoesPadrao.put(SQLGrammarException.class, "error.default.sql.grammar.exceptio");
		excecoesPadrao.put(StaleStateException.class, "error.default.stale.stale.exception");
		excecoesPadrao.put(HibernateException.class, "error.default.hibernate.exception");
	}
	
    /**
     * This method is overriden to provide an alternative implementation for storing the exception.
     * This method will use a pattern matching algorithm to extract a possible resource message that is used instead
     * of the argument exception's message.
     */
    public ActionForward execute(Exception exception,
                                 ExceptionConfig exceptionConfig,
                                 ActionMapping mapping,
                                 ActionForm actionForm,
                                 HttpServletRequest request,
                                 HttpServletResponse response) throws ServletException {
    	
    	MessageResources messageResources = (MessageResources)request.getAttribute(Globals.MESSAGES_KEY);
    	Locale locale = (Locale)request.getSession().getAttribute(Globals.LOCALE_KEY);
    	
    	Collection<ActionMessage> mensagens = new ArrayList<ActionMessage>();
    	
    	ActionForward forward;
  
    	ExceptionUtil exceptionUtil = new ExceptionUtil();

        try{
        	Collection<String> chaves = new ArrayList<String>();
        	Map<String, Collection<String>> parametros = new HashMap<String, Collection<String>>();
        	
        	exceptionUtil.parseExceptionMessage(request, exception, messageResources, locale, chaves, parametros);
        	
        	Iterator it = chaves.iterator();
                
        	while(it.hasNext()){
        		String chave = (String)it.next();
        		if(parametros.get(chave) == null || parametros.get(chave).size() == 0)
        			mensagens.add(new ActionMessage(chave));
        		else
        			mensagens.add(new ActionMessage(chave, parametros.get(chave).toArray()));
            }
        }catch (Throwable parseException){
        	// no pattern was found, so just continue as usual
        	ActionMessages messages = (ActionMessages)request.getSession().getAttribute(Globals.MESSAGE_KEY);
		mensagens.add(new ActionMessage(exceptionConfig.getKey(), parseException.getMessage()));
        }
            
        // Store the exception
        request.setAttribute(Globals.EXCEPTION_KEY, exception);
        request.getSession().setAttribute(Globals.EXCEPTION_KEY, exception);
        exceptionUtil.storeException(request, mensagens);
        
        //PrintStackTraceException
        exception.printStackTrace();
        
        if (exceptionConfig.getPath() != null)
        {
            forward = new ActionForward(exceptionConfig.getPath());
        }
        else
        {
            forward = new ActionForward("/ForwardAction.do?path=&modulo=");
        }
        
        return forward;
    }
    
   /**
     * Retrieves the message and attempts to extract
     * the specified pattern defined within this class. If a string can not be
     * found matching the pattern, the message itself is returned.
     *
     * @param exception the Exception containing the message to retrieve, should not be <code>null</code>
     * @return the retrieved string matching the pattern.
     * @throws Throwable rethrows the cause of the argument exception (which might be the exception itself)
     *      in case no pattern was found in its message
     */
    private void parseExceptionMessage(HttpServletRequest request, Exception exception, MessageResources messageResources, Locale locale, Collection<String> chaves, Map<String, Collection<String>> parametros) throws Throwable
    {
    	String exceptionMessage = null;
    	
    	chaves.clear();
    	parametros.clear();
    	
    	findRootCause(request, exception, chaves, parametros, messageResources, locale);
        
        if(chaves == null || chaves.size() == 0){
		ActionMessages messages = (ActionMessages)request.getSession().getAttribute(Globals.MESSAGE_KEY);
        	if(messages == null || messages.size("$errorMessagesKey") == 0)
			if( !parseExceptionMessage(request, exception, messageResources, locale))
	        		throw new Exception();
	}
        
    
    }

    private boolean parseExceptionMessage(HttpServletRequest request, Exception exception, MessageResources messageResources, Locale locale){
	return findRootCause(request, exception, messageResources, locale);
    }

    /**
     * Finds the root cause of the parent exception
     * by traveling up the exception tree
     */
    private void findRootCause(HttpServletRequest request, Throwable throwable, Collection<String> chaves, Map<String, Collection<String>> parametros, MessageResources messageResources, Locale locale)
    {
    	
    	if (throwable != null)
        {
    		if(throwable.getMessage() != null){
    			String message = throwable.getMessage();
    			//int indice = message.indexOf(" ");
    			//if(indice != -1) message = message.substring(0, indice);
    			StringTokenizer st = new StringTokenizer(message, ",");
    			Collection<String> parametrosMensagem = new ArrayList<String>();
    			boolean key = true;
    			while (st.hasMoreTokens()) {
				String token = st.nextToken().trim();
				
				if(key){
					key = false;
					if(!messageResources.isPresent(locale, token)) break;
					chaves.add(token);
					parametros.put(token, parametrosMensagem);
				}else{
					parametrosMensagem.add(token);
				}
			}
		}
        	
    	    	if (getCause((Exception)throwable) != null)
            	{
                	throwable = getCause((Exception)throwable);
                	findRootCause(request, throwable, chaves, parametros, messageResources, locale);
            	}
        }
    }

    private boolean findRootCause(HttpServletRequest request, Throwable throwable, MessageResources messageResources, Locale locale)
    {
    	if (throwable != null)
        {
    	 	if(verifyExceptionsDefault(request, throwable))
			return true;
    	    	else if (getCause((Exception)throwable) != null)
            	{
                	throwable = getCause((Exception)throwable);
                	return findRootCause(request, throwable, messageResources, locale);
            	}else
			return false;
        }

	return false;
    }
    
    private Throwable getCause(Throwable e){
    	if(e instanceof EJBException) {
    		return ((EJBException)e).getCausedByException();
		}
    	else
    		return e.getCause();
    }

    private boolean verifyExceptionsDefault(HttpServletRequest request, Throwable throwable) {
    	Iterator it = listExcecoesPadrao.iterator();
    	
    	Collection<ActionMessage> mensagens = new ArrayList<ActionMessage>();
    	
	boolean foundException = false; 

    	while(it.hasNext()){
    		Class classe = (Class)it.next();
    		if(classe.isAssignableFrom(throwable.getClass())){
			foundException = true;
    			mensagens.add(new ActionMessage((String)excecoesPadrao.get(classe)));
    			break;
    		}
    	}
    	storeException(request, mensagens);
	return foundException;
     }

	/**
     * Alternative implementation to the one offered by the parent class. Exceptions are also stored under
     * <code>org.apache.struts.Globals.MESSAGE_KEY</code> in session scope.
     */
    protected void storeException(HttpServletRequest request, Collection<ActionMessage> mensagens)
    {
		final HttpSession session = request.getSession();
		ActionMessages messages = (ActionMessages) session.getAttribute(Globals.MESSAGE_KEY);
		if (messages == null) {
			messages = new ActionMessages();
		}

		Iterator it = mensagens.iterator();

		ActionMessages novoMmessages = new ActionMessages();

		Iterator iteMessages = messages.get("org.andromda.bpm4struts.errormessages");
		while (iteMessages.hasNext()) {
			ActionMessage aMMessages = (ActionMessage) iteMessages.next();
			novoMmessages.add("org.andromda.bpm4struts.errormessages", aMMessages);
		}

		while (it.hasNext()) {
			ActionMessage aMLocal = (ActionMessage) it.next();

			boolean found = false;

			iteMessages = messages.get("org.andromda.bpm4struts.errormessages");
			while (iteMessages.hasNext()) {
				ActionMessage aMMessages = (ActionMessage) iteMessages.next();

				if (aMMessages.getKey().equals(aMLocal.getKey())) {
					found = true;
				}
			}

			if (found)
				continue;

			messages.add("org.andromda.bpm4struts.errormessages", aMLocal);
			novoMmessages.add("org.andromda.bpm4struts.errormessages", aMLocal);
		}

		session.setAttribute(Globals.MESSAGE_KEY, novoMmessages);
    }    
}